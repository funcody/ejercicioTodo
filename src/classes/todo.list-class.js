// Clase para agrupar toda la lista las instancias de tudus que hagamosimport { Todo, } from '../classes';import {crearTodoHtml, eliminarTodosTudus} from "../js/componentes";import {todoList} from "../index";  // importamos la instancia todoList de index.js que fue donde se creóexport class TodoList {    constructor() {        //this._todos = [];        // La linea de arriba ya no es necesaria, ya que si no existe en la función la estamos inicializando en la función cargarLocalStorage().        // Si existe va a pasar los datos guardados al this._todos        this.cargarLocalStorage()    }    // Va a introducir dentro del array el tudu que le enviemos.    nuevoTodo(todo) {        this._todos.push(todo)        this.guardarLocalStorage();    }    // Busca por el id y elimina de array el tudu señalado.    eliminarTodo(id) {        // El profe lo ha hecho así:        // Lo que consigue es que consigue un array con todos los tudus que no coinciden con el tudu enviado. Al        // Asignárselo al array principal, borra toro lo que hay y lo reemplaza por este, que es el mismo menos con el enviado.        this._todos = this._todos.filter(todo => todo._id !== id);        // Así lo hice yo:        //const borrarTodo = this._todos.filter(elemento => elemento._id === id);        //const indiceBorrarTodo = this._todos.indexOf(borrarTodo);        //this._todos.splice(indiceBorrarTodo, 1);        this.guardarLocalStorage();    }    // Va a buscar por id cual es el tudu. Si está completado se pone como no completado, si lo está entonces como no completado.    marcarCompletado(id) {        /*        Así lo ha hecho el profesor:        for (const tudu of this._todos){            if (tudu.id === id){                tudu._completado = !tudu._completado;                this.guardarLocalStorage();                break;            }        }        */        const todoCompletado = this._todos.find(idRecibido => idRecibido._id === id);        // Si todoCompletado._completado es igual a true, entonces todoCompletado._completado es igual a falso.        // Si es falso, entonces es igual a true. Siempre hace lo contrario de como esté.        todoCompletado._completado = !todoCompletado._completado;        this.guardarLocalStorage();    }    eliminarCompletados() {        // El profe:        this._todos = this._todos.filter(todo => !todo._completado); // Si es diferente de true        // El mio        /*// Eliminar todos los que tengan tudu completado === true        const todosCompletados = this._todos.filter(elemento => elemento._completado === true);        for (let i = 0; i < todosCompletados.length; i++){            const indiceBorrarTodo = this._todos.indexOf(todosCompletados[i]);            this._todos.splice(indiceBorrarTodo, 1);        }*/        this.guardarLocalStorage();    }    guardarLocalStorage() {        // Aquí vamos a poder almacenar información que necesite nuestra aplicación. En este caso todos en el array        // de todos los tudus en formato JSON.        // JSON.stringify(): Sirve para enviar un objeto en un json perfecto.        localStorage.setItem('todo', JSON.stringify(this._todos));    }    cargarLocalStorage() {        // localStorage.getItem --> Devuelve el valor de la clave cuyo nombre se le pasa por parámetro.        // Siempre que trabajemos con localStorage, si hay alguna llave grabada, debemos validar si ese objeto existe.        // Si this._todos existe entonces los recupero        // JSON.parse(), sirve convertir un JSON a un objeto        // En el caso de que no exista, no teníamos nada aún grabado en el localStorage o el usuario había borrado la        // caché o purgado la caché desde localStorage.        // Si no existe vamos a decir que this._todos va a ser igual a un array vacío y de esa manera lo inicializo. this._todos = [];        this._todos = (localStorage.getItem('todo'))                    ? this._todos = JSON.parse( localStorage.getItem('todo'))                    : [];        // Las instancias han dejado de serlo, convirtiéndose en solamente objetos.        // Para reconstruir estas objetos en instancias, le pasamos una función (que se encuentra en la Clase principal) a cada uno de ellos.        this._todos = this._todos.map(obj => Todo.fromJson (obj)); // Se utiliza map porque crea un array con la condición dada, que es un objeto nuevo creado instancia.    }    // ---- VARIACIÓN HECHA POR MI PARA EJECUTAR EL LOS FILTROS    mostrarTodosTodos(){        eliminarTodosTudus();        todoList._todos.forEach(todo => crearTodoHtml(todo));    }    mostrarTodosPendientes () {        // Guardamos en una variable todos los no completados.        const todosPendientes = this._todos.filter(x => x._completado !== true);        // Eliminamos todos los li del html        eliminarTodosTudus();        // Mostramos solo los no completados        todosPendientes.forEach(todo => crearTodoHtml(todo));    }    mostrarTodosCompletados () {        // Guardamos en una variable todos los completados.        const todosPendientes = this._todos.filter(x => x._completado === true);        // Eliminamos todos los li del html        eliminarTodosTudus();        // Mostramos solo los no completados        todosPendientes.forEach(todo => crearTodoHtml(todo));    }    mostrarNumeroTodosPendientes () {        let contadorTodosPendientes = 0;        this._todos.forEach(x => {            if (x._completado !== true){                contadorTodosPendientes++;            }        });        return contadorTodosPendientes;    }}